### 慢接口溯源
1. 日志分析。在有完整日志的情况下，追踪日志时间，先找到时间占用旧的操作
2. 代码分析。会导致慢接口的情况：列表遍历查询数据库、列表遍历查询RPC、SQL慢查、线程池阻塞

### SQL慢查分析与优化
1. **EXPLAIN分析。**EXPLAIN有几个重要的分析指标，同一个类型的SQL会根据条件匹配到的数据量来分析会走哪个索引，尽量保证是扫描最小行数来最快找到结果。
   
   ```
   type:索引等级。ALL、index、range、 ref、eq_ref、const、system、NULL（从左到右，性能从差到好）
   possible_keys:可能会用的索引。
   key:实际使用的索引。
   rows:扫描行数。
   ```
   
2. **查询只获取需要字段内容。**在数据量化的情况下，每多一个字段都会多一次开销，尽量减少查询字段
3. **建立联合索引。**此方案适用于一些会频繁查询条件的场景，联合索引设计尽量是保证左侧是等值查询、区分度高（常用的查询条件左侧第一个索引尽量要区分度高），尽量避免索引字段是频繁更新的字段。
   反例：
   ```
   #这里field_a是个经常使用的条件，但是IN的数据太多，则不适合作为联合索引的左侧，因为这样区分度不高，可能会导致全表检索
   SELECT * FROM table_a WHERE field_a in(1,2,3,4....1000) AND create_time BETWEEN '2021-01-01 00:00:00' AND '2021-01-01 23:59:59'
   ```
4. **分批查询。**此方案适用于一些有序的范围查询场景，比如分页总数查询。及时查询条件上是有索引，但是当条件超过一定范围后，是会变成全表扫描的，这种情况可以利用强制索引的SQL与普通SQL进行EXPLAIN比较，对比扫描行数。分批查询可在代码层使用多线程来提高查询效率，避免分片过多导致的接口慢查询。多线程查询需要注意线程安全问题，分片需要注意临界点问题。

   例子：
      ```
      #此处查7天的总数会带来慢查，可按时间分片，每6小时查一次结果，然后程序再汇总结果
      SELECT COUNT(1) FROM table_a WHERE create_time BETWEEN '2021-01-01 00:00:00' AND '2021-01-07 23:59:59' ORDER BY create_time desc
      ```
5. **合理利用索引排序。**当查询使用的索引与排序的索引不一致时，会给MySQL服务带来排序计算的压力

      反例：
      ```
      SELECT * FROM table_a WHERE create_time BETWEEN '2021-01-01 00:00:00' AND '2021-01-01 23:59:59' ORDER BY update_time desc
      ```
      正例：
      ```
      SELECT * FROM table_a WHERE create_time BETWEEN '2021-01-01 00:00:00' AND '2021-01-01 23:59:59' ORDER BY create_time desc
      ```
6. **避免MySQL进行大数据量函数计算。**MySQL的专业是存储，而不是计算，当数据量大的时候，函数计算是会存在慢查的。如果系统不需要精确结果的情况下，可以通过缓存的方式缓解数据压力；需要精确计算则需要结合大数据工具来完成计算。
7. **合理利用主键。**在一些大数据量的范围查询场景，如果没有其他合理索引可用，但是可以获取最大最小主键值，则可以先获取主键值，然后在查询条件加上主键的范围查询。
8. **强制索引（不推荐）。**此方式适合于没有其他最优方案，但是SQL依然会走错索引的情况。弊端：带来程序维护问题、数据库迁移问题
   例子：
      ```
      SELECT COUNT(1) FROM table_a FORCE INDEX(idx_create_time) WHERE create_time BETWEEN '2021-01-01 00:00:00' AND '2021-01-07 23:59:59' ORDER BY create_time desc
      ```